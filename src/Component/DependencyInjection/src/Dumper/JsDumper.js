const EnvVariableResource = Jymfony.Component.Config.Resource.EnvVariableResource;
const ArgumentInterface = Jymfony.Component.DependencyInjection.Argument.ArgumentInterface;
const IteratorArgument = Jymfony.Component.DependencyInjection.Argument.IteratorArgument;
const ServiceClosureArgument = Jymfony.Component.DependencyInjection.Argument.ServiceClosureArgument;
const ServiceLocatorArgument = Jymfony.Component.DependencyInjection.Argument.ServiceLocatorArgument;
const AnalyzeServiceReferencesPass = Jymfony.Component.DependencyInjection.Compiler.AnalyzeServiceReferencesPass;
const Container = Jymfony.Component.DependencyInjection.Container;
const ContainerBuilder = Jymfony.Component.DependencyInjection.ContainerBuilder;
const Definition = Jymfony.Component.DependencyInjection.Definition;
const RuntimeException = Jymfony.Component.DependencyInjection.Exception.RuntimeException;
const ServiceCircularReferenceException = Jymfony.Component.DependencyInjection.Exception.ServiceCircularReferenceException;
const Parameter = Jymfony.Component.DependencyInjection.Parameter;
const Reference = Jymfony.Component.DependencyInjection.Reference;
const ServiceLocator = Jymfony.Component.DependencyInjection.ServiceLocator;
const Variable = Jymfony.Component.DependencyInjection.Variable;
const path = require('path');

const firstChars = 'abcdefghijklmnopqrstuvwxyz';
const nonFirstChars = 'abcdefghijklmnopqrstuvwxyz0123456789_';

/**
 * Dumps container in a js class.
 *
 * @memberOf Jymfony.Component.DependencyInjection.Dumper
 */
export default class JsDumper {
    /**
     * Constructor.
     *
     * @param {Jymfony.Component.DependencyInjection.ContainerBuilder} container
     */
    __construct(container) {
        if (! container.frozen) {
            throw new RuntimeException('Cannot dump an uncompiled container. Please call compile() on your builder first');
        }

        this._container = container;
        this._inlinedDefinitions = new Map();
        this._serviceIdToMethodNameMap = undefined;
        this._usedMethodNames = undefined;
        this._definitionVariables = undefined;
        this._referenceVariables = undefined;
        this._variableCount = undefined;
        this._targetDirMaxMatches = undefined;
        this._targetDirRegex = undefined;
    }

    /**
     * Dumps the service container.
     *
     * Available options:
     *  * class_name: The class name [default: ProjectContainer]
     *  * base_class: The base class name [default: Jymfony.Component.DependencyInjection.Container]
     *  * build_time: The build unix time.
     *
     * @param {Object.<string, *>} [options = {}]
     *
     * @returns {Object<string, string>}
     */
    dump(options = {}) {
        options = Object.assign({}, {
            base_class: 'Jymfony.Component.DependencyInjection.Container',
            class_name: 'ProjectContainer',
            build_time: ~~(Date.now() / 1000),
        }, options);

        (new AnalyzeServiceReferencesPass()).process(this._container);

        if (options.dir) {
            const dir = __jymfony.rtrim(options.dir, '/').split(path.sep);
            let i = dir.length;

            if (3 <= i) {
                let regex = '';
                const lastOptionalDir = 8 < i ? i - 5 : 3;
                this._targetDirMaxMatches = i - lastOptionalDir;

                while (--i >= lastOptionalDir) {
                    regex = __jymfony.sprintf('(%s%s)?', __jymfony.regex_quote(path.sep + dir[i]), regex);
                }

                do {
                    regex = __jymfony.regex_quote(path.sep + dir[i]) + regex;
                } while (0 < --i);

                this._targetDirRegex = new RegExp(__jymfony.regex_quote(dir[0]) + regex);
            }
        }

        this._initMethodNamesMap(options.base_class);

        let main = this._startClass(options.class_name, options.base_class);
        main += this._getServices();
        main += this._getDefaultParametersMethod();
        main += this._endClass(options.class_name);

        const hash = ContainerBuilder.hash(main).replace(/[._]/g, 'x');
        const code = {
            ['Container'+hash+'/'+options.class_name+'.js']: main,
        };

        const time = options.build_time;
        const id = __jymfony.crc32(hash + time);

        code[options.class_name + '.js'] = `
// This file has been auto-generated by the Jymfony Dependency Injection Component for internal use.
const Container${hash} = require('./Container${hash}/${options.class_name}.js');

module.exports = new Container${hash}({
    'container.build_hash': '${hash}',
    'container.build_id': '${id}',
    'container.build_time': ${time},
});

`;

        return code;
    }

    /**
     * @param {string} baseClass
     *
     * @private
     */
    _initMethodNamesMap(baseClass) {
        this._serviceIdToMethodNameMap = new Map();
        this._usedMethodNames = new Set();

        try {
            const reflectionClass = new ReflectionClass(baseClass);
            for (const method of reflectionClass.methods) {
                this._usedMethodNames.add(method);
            }
        } catch (e) {
            // Do nothing
        }
    }

    /**
     * @param {string} className
     * @param {string} baseClass
     *
     * @returns {string}
     *
     * @private
     */
    _startClass(className, baseClass) {
        const targetDirs = undefined === this._targetDirMaxMatches ? '' : `
        let dir = path.dirname(__dirname);
        this._targetDirs = [ dir ];
        for (let i = 1; i <= ${this._targetDirMaxMatches}; ++i) {
            this._targetDirs.push(dir = path.dirname(dir));
        }

`;

        return `const Container = Jymfony.Component.DependencyInjection.Container;
const LogicException = Jymfony.Component.DependencyInjection.Exception.LogicException;
const FrozenParameterBag = Jymfony.Component.DependencyInjection.ParameterBag.FrozenParameterBag;
const RewindableGenerator = Jymfony.Component.DependencyInjection.Argument.RewindableGenerator;
const path = require('path');

class ${className} extends ${baseClass} {
    __construct(buildParameters = {}) {${targetDirs}
        super.__construct(new FrozenParameterBag(Object.assign({}, this._getDefaultsParameters(), buildParameters)));

        ${this._getMethodMap()}
        ${this._getAliases()}
        this._privates = {};
    }

    compile() {
        throw new LogicException('You cannot compile a dumped container');
    }

    get frozen() {
        return true;
    }
`;
    }

    /**
     * @param {string} className
     *
     * @returns {string}
     *
     * @private
     */
    _endClass(className) {
        return `
}

module.exports = ${className};
`;
    }

    /**
     * @returns {string}
     *
     * @private
     */
    _getMethodMap() {
        let code = `this._methodMap = {
`;

        const definitions = this._container.getDefinitions();
        const ids = Object.keys(definitions).sort();
        for (const id of ids) {
            const definition = definitions[id];
            if (! definition.isPublic() || definition.isSynthetic()) {
                continue;
            }

            code += '            ' + this._export(id) + ': ' + this._export(this._generateMethodName(id)) + ',\n';
        }

        return code + '        };\n';
    }

    /**
     * @returns {string}
     *
     * @private
     */
    _getAliases() {
        let code = `this._aliases = {
`;

        const aliases = this._container.getAliases();
        const ids = Object.keys(aliases).sort();
        for (const alias of ids) {
            let id = aliases[alias].toString();
            while (undefined !== aliases[id]) {
                id = aliases[id].toString();
            }

            code += '            ' + this._export(alias) + ': ' + this._export(id) + ',\n';
        }

        return code + '        };\n';
    }

    /**
     * @param {*} value
     *
     * @returns {string}
     *
     * @private
     */
    _export(value) {
        if (undefined !== this._targetDirRegex && isString(value) && value.match(this._targetDirRegex)) {
            value = JSON.stringify(value);
            value = value.replace(this._targetDirRegex, (...args) => {
                for (let i = this._targetDirMaxMatches; 1 <= i; --i) {
                    if (undefined === args[i]) {
                        continue;
                    }

                    return '" + this._targetDirs[' + (this._targetDirMaxMatches - i) + '] + "';
                }
            });

            return value.replace(/"" \+ /g, '').replace(/ \+ ""/g, '');
        }

        return this._doExport(value);
    }

    /**
     * @param {*} value
     *
     * @returns {string}
     *
     * @private
     */
    _doExport(value) {
        if (isScalar(value) || isArray(value) || isObjectLiteral(value)) {
            return JSON.stringify(value);
        }

        if (undefined === value) {
            return 'undefined';
        }

        if (null === value) {
            return 'null';
        }

        throw new Error('Unimplemented exporting value "' + value + '"');
    }

    /**
     * @param {string} id
     *
     * @returns {string}
     *
     * @private
     */
    _generateMethodName(id) {
        if (this._serviceIdToMethodNameMap[id]) {
            return this._serviceIdToMethodNameMap[id];
        }

        let name = Container.camelize(id);
        name = name.replace(/[^a-zA-Z0-9_\x7f-\xff]/g, '');

        let methodName = `get${name}Service`;
        let suffix = 1;

        while (this._usedMethodNames.has(methodName)) {
            ++suffix;
            methodName = `get${name}${suffix}Service`;
        }

        this._serviceIdToMethodNameMap[id] = methodName;
        this._usedMethodNames.add(methodName);

        return methodName;
    }

    /**
     * @returns {string}
     *
     * @private
     */
    _getServices() {
        let publicServices = '', privateServices = '';
        const serviceIds = Object.keys(this._container.getDefinitions()).sort();
        for (const id of serviceIds) {
            const definition = this._container.getDefinition(id);
            if (definition.isPublic()) {
                publicServices += this._getService(id, definition);
            } else {
                privateServices += this._getService(id, definition);
            }
        }

        return publicServices + privateServices;
    }

    /**
     * @returns {string}
     *
     * @private
     */
    _getDefaultParametersMethod() {
        let code = '{\n';
        const parameters = this._container.parameterBag.all();
        for (const key of Object.keys(parameters)) {
            code += `            "${key}": ${this._dumpParameter(key, false)},` + '\n';
        }
        code += '        }';

        return `
    _getDefaultsParameters() {
        return ${code};
    }`;
    }

    /**
     * Generate a service.
     *
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @private
     */
    _getService(id, definition) {
        if (definition.isSynthetic()) {
            return '';
        }

        this._definitionVariables = new Map();
        this._referenceVariables = {};
        this._variableCount = 0;

        let class_;
        const returns = [];

        if (definition.isSynthetic()) {
            returns.push('@throws {Jymfony.Component.DependencyInjection.RuntimeException} always since this service is expected to be injected dynamically');
        } else if ((class_ = definition.getClass())) {
            returns.push('@returns {' + (-1 !== class_.indexOf('%') ? '*' : class_) + '}');
        } else if (definition.getFactory() || definition.getModule()) {
            returns.push('@returns {Object}');
        }

        if (definition.isDeprecated()) {
            returns.push('@deprecated ' + definition.getDeprecationMessage(id));
        }

        let doc = '';
        const visibility = definition.isPublic() ? 'public ' : '';
        const shared = definition.isShared() ? 'shared ' : '';

        let lazyInitialization = '';
        if (definition.isLazy()) {
            doc = '     * @param {boolean} lazyLoad Whether to try to lazy-load this service' + doc;
            lazyInitialization = 'lazyLoad = true';
        }

        if (doc.length) {
            doc += '\n';
        }

        const methodName = this._generateMethodName(id);
        return `
    /**
     * Gets the ${visibility}'${id}' ${shared}service.
     *
${doc}     * ${returns.join('\n     * ').replace(/\n     * \n/g, '\n     *\n')}
     */
    ${methodName}(${lazyInitialization}) {
${this._addLocalTempVariables(id, definition)}\
${this._addInlinedDefinitions(id, definition)}\
${this._addServiceInstance(id, definition)}\
${this._addInlinedDefinitionsSetup(id, definition)}\
${this._addProperties(definition)}\
${this._addMethodCalls(definition)}\
${this._addShutdownCalls(definition)}\
${this._addConfigurator(definition)}\
${this._addReturn(id, definition)}\
    }
`;
    }

    /**
     * @param {string} cId
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @returns {string}
     *
     * @private
     */
    _addLocalTempVariables(cId, definition) {
        const template = '        let %s = %s;\n';

        const localDefinitions = [ definition, ...this._getInlinedDefinitions(definition) ];

        const calls = {};
        const behavior = {};

        for (const iDefinition of localDefinitions) {
            this._getServiceCallsFromArguments(iDefinition.getArguments(), calls, behavior);
            this._getServiceCallsFromArguments(iDefinition.getMethodCalls(), calls, behavior);
            this._getServiceCallsFromArguments(iDefinition.getShutdownCalls(), calls, behavior);
            this._getServiceCallsFromArguments(iDefinition.getProperties(), calls, behavior);
            this._getServiceCallsFromArguments([ iDefinition.getConfigurator() ], calls, behavior);
            this._getServiceCallsFromArguments([ iDefinition.getFactory() ], calls, behavior);
        }

        let code = '';
        for (const [ id, callCount ] of __jymfony.getEntries(calls)) {
            if ('service_container' === id || id === cId) {
                continue;
            }

            if (1 < callCount) {
                const name = this._getNextVariableName();
                this._referenceVariables[id] = new Variable(name);

                if (Container.EXCEPTION_ON_INVALID_REFERENCE === behavior[id]) {
                    code += __jymfony.sprintf(template, name, this._getServiceCall(id));
                } else {
                    code += __jymfony.sprintf(template, name, this._getServiceCall(id, new Reference(id, Container.NULL_ON_INVALID_REFERENCE)));
                }
            }
        }

        if ('' !== code) {
            code += '\n';
        }

        return code;
    }

    /**
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @returns {string}
     *
     * @private
     */
    _addInlinedDefinitions(id, definition) {
        let code = '';
        const nbOccurrences = new Map();
        const processed = new Set();
        const inlinedDefinitions = this._getInlinedDefinitions(definition);

        for (const iDefinition of inlinedDefinitions) {
            if (! nbOccurrences.has(iDefinition)) {
                nbOccurrences.set(iDefinition, 1);
            } else {
                const i = nbOccurrences.get(iDefinition);
                nbOccurrences.set(iDefinition, i + 1);
            }
        }

        for (const sDefinition of inlinedDefinitions) {
            if (processed.has(sDefinition)) {
                continue;
            }
            processed.add(sDefinition);

            if (1 < nbOccurrences.get(sDefinition) || sDefinition.getMethodCalls().length ||
                sDefinition.getShutdownCalls().length || Object.keys(sDefinition.getProperties()).length ||
                sDefinition.getConfigurator()) {
                const name = this._getNextVariableName();
                this._definitionVariables.set(sDefinition, new Variable(name));

                if (this._hasReference(id, sDefinition.getArguments())) {
                    throw new ServiceCircularReferenceException(id, [ id ]);
                }

                code += this._addNewInstance(sDefinition, 'let ' + name, ' = ');

                if (! this._hasReference(id, sDefinition.getMethodCalls(), true) && ! this._hasReference(id, sDefinition.getProperties(), true)) {
                    code += this._addProperties(sDefinition, name);
                    code += this._addMethodCalls(sDefinition, name);
                    code += this._addShutdownCalls(sDefinition, name);
                    code += this._addConfigurator(sDefinition, name);
                }

                code += '\n';
            }
        }

        return code;
    }

    /**
     * Generate service instance
     *
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @returns {string}
     *
     * @private
     */
    _addServiceInstance(id, definition) {
        const simple = this._isSimpleInstance(id, definition);
        let instantiation = '';
        if (definition.isShared()) {
            const variable = definition.isPublic() ? '_services' : '_privates';
            instantiation = `this.${variable}["${id}"] = ` + (simple ? '' : 'instance');
        } else {
            instantiation = 'instance = ';
        }

        let ret = '';
        if (simple) {
            ret = 'return ';
        } else {
            instantiation += ' = ';
        }

        let code = this._addNewInstance(definition, ret, instantiation);
        if (! definition.isShared() || ! simple) {
            code = '        let instance;\n' + code;
        }

        if (! simple) {
            code += '\n';
        }

        return code;
    }

    /**
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @returns {string}
     *
     * @private
     */
    _addInlinedDefinitionsSetup(id, definition) {
        this._referenceVariables[id] = 'instance';
        let code = '';
        const processed = new Set();

        for (const iDefinition of this._getInlinedDefinitions(definition)) {
            if (processed.has(iDefinition)) {
                continue;
            }

            processed.add(iDefinition);

            if (! this._hasReference(id, iDefinition.getMethodCalls(), true) &&
                ! this._hasReference(id, iDefinition.getShutdownCalls(), true) &&
                ! this._hasReference(id, iDefinition.getProperties(), true)) {
                continue;
            }

            // If the instance is simple, the return statement has already been generated
            // So, the only possible way to get there is because of a circular reference
            if (this._isSimpleInstance(id, definition)) {
                throw new ServiceCircularReferenceException(id, [ id ]);
            }

            const name = this._definitionVariables.get(iDefinition);
            code += this._addMethodCalls(iDefinition, name);
            code += this._addShutdownCalls(iDefinition, name);
            code += this._addProperties(iDefinition, name);
            code += this._addConfigurator(iDefinition, name);
        }

        if ('' !== code) {
            code += '\n';
        }

        return code;
    }

    /**
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     * @param {string|Jymfony.Component.DependencyInjection.Variable} [variableName = instance]
     *
     * @returns {string}
     *
     * @private
     */
    _addProperties(definition, variableName = 'instance') {
        let code = '';
        for (const [ name, value ] of __jymfony.getEntries(definition.getProperties())) {
            code += __jymfony.sprintf('        %s.%s = %s;\n', variableName, name, this._dumpValue(value));
        }

        return code;
    }

    /**
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     * @param {string|Jymfony.Component.DependencyInjection.Variable} [variableName = instance]
     *
     * @returns {string}
     *
     * @private
     */
    _addMethodCalls(definition, variableName = 'instance') {
        let code = '';

        for (const call of definition.getMethodCalls()) {
            const args = [];
            for (const value of call[1]) {
                args.push(this._dumpValue(value));
            }

            code += this._wrapServiceConditionals(call[1], __jymfony.sprintf('        %s.%s(%s);\n', variableName, call[0], args.join(', ')));
        }

        return code;
    }

    /**
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     * @param {string|Jymfony.Component.DependencyInjection.Variable} [variableName = instance]
     *
     * @returns {string}
     *
     * @private
     */
    _addShutdownCalls(definition, variableName = 'instance') {
        let code = '';

        for (const call of definition.getShutdownCalls()) {
            const args = [];
            for (const value of call[1]) {
                args.push(this._dumpValue(value));
            }

            code += this._wrapServiceConditionals(call[1], __jymfony.sprintf('        this.registerShutdownCall(%s.%s.bind(%s, %s));\n', variableName, call[0], variableName, args.join(', ')));
        }

        return code;
    }

    /**
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     * @param {string|Jymfony.Component.DependencyInjection.Variable} [variableName = instance]
     *
     * @returns {string}
     *
     * @private
     */
    _addConfigurator(definition, variableName = 'instance') {
        const callable = definition.getConfigurator();
        if (! callable) {
            return '';
        }

        if (isArray(callable)) {
            if (callable[0] instanceof Reference || (callable[0] instanceof Definition && this._definitionVariables.has(definition))) {
                return __jymfony.sprintf('        %s.%s(%s);\n', this._dumpValue(callable[0]), callable[1], variableName);
            }

            const class_ = this._dumpValue(callable[0]);
            throw new RuntimeException(class_);
        }

        return __jymfony.sprintf('        %s(%s);\n', callable, variableName);
    }

    /**
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @returns {string}
     *
     * @private
     */
    _addReturn(id, definition) {
        if (this._isSimpleInstance(id, definition)) {
            return '';
        }

        return '        return instance;\n';
    }

    /**
     * @param {*} value
     * @param {boolean} [interpolate = true]
     *
     * @returns {string}
     *
     * @throws {Jymfony.Component.DependencyInjection.Exception.RuntimeException}
     *
     * @private
     */
    _dumpValue(value, interpolate = true) {
        if (value instanceof ArgumentInterface) {
            const scope = [ this._definitionVariables, this._referenceVariables, this._variableCount ];
            this._definitionVariables = this._referenceVariables = undefined;

            try {
                if (value instanceof ServiceClosureArgument) {
                    value = value.values[0];
                    const code = this._dumpValue(value, interpolate);

                    return __jymfony.sprintf('() => {\n            return %s;\n        }', code);
                }

                if (value instanceof IteratorArgument) {
                    const operands = [ 0 ];
                    const code = [ 'new RewindableGenerator((function * () {' ];
                    const values = value.values;
                    let countCode;

                    if (! values || 0 === Object.keys(values).length) {
                        code.push('            return new EmptyIterator();');
                    } else {
                        countCode = [ 'function () {' ];

                        for (let v of Object.values(values)) {
                            const c = this._getServiceConditionals(v);
                            if (c) {
                                operands.push('((' + c + ') ? 1 : 0)');
                            } else {
                                ++operands[0];
                            }

                            v = this._wrapServiceConditionals(v, __jymfony.sprintf('        yield %s;\n', this._dumpValue(v, interpolate)));
                            for (const line of v.split('\n')) {
                                if (line) {
                                    code.push('    ' + line);
                                }
                            }
                        }

                        countCode.push(__jymfony.sprintf('            return %s;', operands.join(' + ')));
                        countCode.push('        }');
                    }

                    code.push(__jymfony.sprintf('        }).bind(this), %s)', 1 < operands.length ? countCode.join('\n') : operands[0]));

                    return code.join('\n');
                }

                if (value instanceof ServiceLocatorArgument) {
                    let serviceMap = '';
                    for (const [ k, v ] of __jymfony.getEntries(value.values)) {
                        if (! v) {
                            continue;
                        }

                        serviceMap += __jymfony.sprintf('\n            %s: %s,',
                            this._export(__jymfony.ltrim(k, '?')),
                            this._dumpValue(new ServiceClosureArgument(v)).replace(/^/mg, '    ').trim(),
                        );
                    }

                    return __jymfony.sprintf('new \%s({%s\n        })', ReflectionClass.getClassName(ServiceLocator), serviceMap);
                }
            } finally {
                [ this._definitionVariables, this._referenceVariables, this._variableCount ] = scope;
            }
        } else if (value instanceof Definition) {
            if (this._definitionVariables && this._definitionVariables.has(value)) {
                return this._dumpValue(this._definitionVariables.get(value), interpolate);
            }

            if (0 < value.getMethodCalls().length) {
                throw new RuntimeException('Cannot dump definitions which have method calls');
            }

            if (0 < value.getShutdownCalls().length) {
                throw new RuntimeException('Cannot dump definitions which have shutdown calls');
            }

            if (value.getConfigurator()) {
                throw new RuntimeException('Cannot dump definitions which have configurator');
            }

            const args = [];
            for (const argument of value.getArguments()) {
                args.push(this._dumpValue(argument));
            }

            const factory = value.getFactory();
            if (factory) {
                if (isString(factory)) {
                    return __jymfony.sprintf('%s(%s)', this._dumpLiteralClass(this._dumpValue(factory)), args.join(', '));
                }

                if (isArray(factory)) {
                    if (isString(factory[0])) {
                        return __jymfony.sprintf('%s.%s(%s)', this._dumpLiteralClass(this._dumpValue(factory[0])), factory[1], args.join(', '));
                    }

                    if (factory[0] instanceof Definition) {
                        return __jymfony.sprintf('getCallableFromArray([%s, \'%s\'])(%s)', this._dumpValue(factory[0]), factory[1], args.join(', '));
                    }

                    if (factory[0] instanceof Reference) {
                        return __jymfony.sprintf('%s.%s(%s)', this._dumpValue(factory[0]), factory[1], args.join(', '));
                    }
                }

                throw new RuntimeException('Cannot dump definition because of invalid factory');
            }

            const class_ = value.getClass();
            if (! class_) {
                throw new RuntimeException('Cannot dump definition which have no class nor factory');
            }

            return __jymfony.sprintf('new %s(%s)', this._dumpLiteralClass(this._dumpValue(class_)), args.join(', '));
        } else if (value instanceof Variable) {
            return value.toString();
        } else if (value instanceof Reference) {
            const id = value.toString();
            if (this._referenceVariables && this._referenceVariables[id]) {
                return this._dumpValue(this._referenceVariables[id], interpolate);
            }

            return this._getServiceCall(id, value);
        } else if (value instanceof Parameter) {
            return this._dumpParameter(value.toString());
        } else if (interpolate && isString(value)) {
            let match;
            if ((match = /^%([^%]+)%$/.exec(value))) {
                return this._dumpParameter(match[1]);
            }

            const replaceParameters = (match, p1, p2) => {
                return '"+' + this._dumpParameter(p2) + '+"';
            };

            return this._export(value).replace(RegExp('(?<!%)(%)([^%]+)\\1', 'g'), replaceParameters).replace(/%%/g, '%');
        } else if (isArray(value) || isObjectLiteral(value)) {
            const code = [];
            for (const [ k, v ] of __jymfony.getEntries(value)) {
                code.push((isArray(value) ? '' : this._dumpValue(k, interpolate) + ': ') + this._dumpValue(v));
            }

            return __jymfony.sprintf(isArray(value) ? '[%s]' : '{%s}', code.join(', '));
        } else if (isObject(value)) {
            throw new RuntimeException('Unable to dump a service container if a parameter is an object');
        } else if (isFunction(value)) {
            throw new RuntimeException('Unable to dump a service container if a parameter is a function');
        } else if (null === value || undefined === value) {
            return this._export(value);
        }

        return value;
    }

    /**
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @returns {Jymfony.Component.DependencyInjection.Definition[]}
     *
     * @private
     */
    _getInlinedDefinitions(definition) {
        if (! this._inlinedDefinitions.has(definition)) {
            const definitions = [
                ...this._getDefinitionsFromArguments(definition.getArguments()),
                ...this._getDefinitionsFromArguments(definition.getMethodCalls()),
                ...this._getDefinitionsFromArguments(definition.getShutdownCalls()),
                ...this._getDefinitionsFromArguments(definition.getProperties()),
                ...this._getDefinitionsFromArguments([ definition.getConfigurator() ]),
                ...this._getDefinitionsFromArguments([ definition.getFactory() ]),
            ];

            this._inlinedDefinitions.set(definition, definitions);
        }

        return this._inlinedDefinitions.get(definition);
    }

    /**
     * @param {*} args
     *
     * @returns {IterableIterator<Jymfony.Component.DependencyInjection.Definition>}
     *
     * @private
     */
    * _getDefinitionsFromArguments(args) {
        for (const argument of Object.values(args)) {
            if (argument instanceof Definition) {
                yield * this._getInlinedDefinitions(argument);
                yield argument;
            } else if (isArray(argument) || isObjectLiteral(argument)) {
                yield * this._getDefinitionsFromArguments(argument);
            }
        }
    }

    /**
     * Dumps a parameter.
     *
     * @param {string} name
     * @param {boolean} [resolveEnv = true]
     *
     * @returns {string}
     *
     * @private
     */
    _dumpParameter(name, resolveEnv = true) {
        if (resolveEnv && 'env()' !== name && 'env(' === name.substr(0, 4) && ')' === name.substr(-1, 1)) {
            const matches = /env\((.+)\)/.exec(name);
            const envVarName = matches[1];

            this._container.addResource(new EnvVariableResource(envVarName));
            return 'this.getParameter(\"env('+envVarName+')\")';
        }

        if (! this._container.hasParameter(name)) {
            return 'this.getParameter(\"'+name+'\")';
        }

        const parameter = this._container.getParameter(name);
        if (parameter instanceof Reference) {
            throw new InvalidArgumentException(__jymfony.sprintf('You cannot dump a container with parameters that contain references to other services (reference to service "%s" found in "%s").', parameter.toString(), name));
        } else if (parameter instanceof Definition) {
            throw new InvalidArgumentException(__jymfony.sprintf('You cannot dump a container with parameters that contain service definitions. Definition for "%s" found in "%s".', parameter.getClass(), name));
        } else if (parameter instanceof Variable) {
            throw new InvalidArgumentException(__jymfony.sprintf('You cannot dump a container with parameters that contain variable references. Variable "%s" found in "%s".', parameter.toString(), name));
        }

        return this._export(parameter);
    }

    /**
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Reference} [reference]
     *
     * @returns {string}
     *
     * @private
     */
    _getServiceCall(id, reference = undefined) {
        while (this._container.hasAlias(id)) {
            id = this._container.getAlias(id).toString();
        }

        if ('service_container' === id) {
            return 'this';
        }

        let code;
        if (this._container.hasDefinition(id)) {
            const definition = this._container.getDefinition(id);
            if (! definition.isSynthetic()) {
                if (undefined !== reference && Container.IGNORE_ON_UNINITIALIZED_REFERENCE === reference.invalidBehavior) {
                    code = 'undefined';
                    if (! definition.isShared()) {
                        return code;
                    }
                } else {
                    code = 'this.' + this._generateMethodName(id) + '()';
                }

                if (definition.isShared()) {
                    code = __jymfony.sprintf('(this._%s[%s] || %s)', definition.isPublic() ? 'services' : 'privates', this._dumpValue(id), code);
                }

                return code;
            }
        }

        if (undefined !== reference && Container.IGNORE_ON_UNINITIALIZED_REFERENCE === reference.invalidBehavior) {
            return 'undefined';
        }

        if (undefined !== reference && Container.EXCEPTION_ON_INVALID_REFERENCE !== reference.invalidBehavior) {
            code = __jymfony.sprintf('this.get(%s, Container.NULL_ON_INVALID_REFERENCE)', this._export(id));
        } else {
            code = __jymfony.sprintf('this.get(%s)', this._export(id));
        }

        return __jymfony.sprintf('(this._services[%s] || %s)', this._export(id), code);
    }

    /**
     * @param {string} class_
     *
     * @returns {string}
     *
     * @private
     */
    _dumpLiteralClass(class_) {
        if ('"' !== class_.charAt(0)) {
            throw new RuntimeException('Invalid class name');
        }

        return class_.substring(1, class_.length-1);
    }

    /**
     * @param {*} args
     * @param {Object} calls
     * @param {Object} behavior
     *
     * @private
     */
    _getServiceCallsFromArguments(args, calls, behavior) {
        for (const argument of Object.values(args)) {
            if (argument instanceof Reference) {
                const id = argument.toString();

                if (! calls[id]) {
                    calls[id] = 0;
                }

                if (! behavior[id]) {
                    behavior[id] = argument.invalidBehavior;
                } else if (Container.EXCEPTION_ON_INVALID_REFERENCE !== behavior[id]) {
                    behavior[id] = argument.invalidBehavior;
                }

                ++calls[id];
            } else if (isArray(argument) || isObjectLiteral(argument)) {
                this._getServiceCallsFromArguments(argument, calls, behavior);
            }
        }
    }

    /**
     * @param {string} id
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     *
     * @returns {boolean}
     *
     * @private
     */
    _isSimpleInstance(id, definition) {
        for (const sDefinition of [ definition, ...this._getInlinedDefinitions(definition) ]) {
            if (definition !== sDefinition &&
                ! this._hasReference(id, sDefinition.getMethodCalls()) &&
                ! this._hasReference(id, sDefinition.getShutdownCalls())) {
                continue;
            }

            if (0 < sDefinition.getMethodCalls().length ||
                0 < Object.keys(sDefinition.getShutdownCalls()).length ||
                0 < Object.keys(sDefinition.getProperties()).length ||
                sDefinition.getConfigurator()) {
                return false;
            }
        }

        return true;
    }

    /**
     * @param {Jymfony.Component.DependencyInjection.Definition} definition
     * @param {string} ret
     * @param {string} instantiation
     *
     * @returns {string}
     *
     * @private
     */
    _addNewInstance(definition, ret, instantiation) {
        if ('Jymfony.Component.DependencyInjection.ServiceLocator' === definition.getClass() && definition.hasTag('container.service_locator')) {
            const args = {};
            for (const [ k, argument ] of __jymfony.getEntries(definition.getArgument(0))) {
                args[k] = argument.values[0];
            }

            return __jymfony.sprintf(`        ${ret}%s;\n`, this._dumpValue(new ServiceLocatorArgument(args)));
        }

        let class_ = this._dumpValue(definition.getClass());
        const args = Array.from(definition.getArguments().map(T => this._dumpValue(T)));

        if (definition.getModule()) {
            const [ module, property ] = definition.getModule();
            if (property) {
                return __jymfony.sprintf(`        ${ret}${instantiation}new (require(%s)[%s])(%s);\n`, this._dumpValue(module), this._dumpValue(property), args.join(', '));
            }

            return __jymfony.sprintf(`        ${ret}${instantiation}require(%s);\n`, this._dumpValue(module));
        } else if (definition.getFactory()) {
            const callable = definition.getFactory();
            if (isArray(callable)) {
                if (callable[0] instanceof Reference || (callable[0] instanceof Definition && this._definitionVariables.has(callable[0]))) {
                    return __jymfony.sprintf(`        ${ret}${instantiation}%s.%s(%s);\n`, this._dumpValue(callable[0]), callable[1], args.join(', '));
                }

                class_ = this._dumpValue(callable[0]);
                if ('"' === class_.charAt(0)) {
                    return __jymfony.sprintf(`        ${ret}${instantiation}%s.%s(%s);\n`, this._dumpLiteralClass(class_), callable[1], args.join(', '));
                }

                if (0 === class_.indexOf('new ')) {
                    return __jymfony.sprintf(`        ${ret}${instantiation}(%s).%s(%s);\n`, class_, callable[1], args.join(', '));
                }

                return __jymfony.sprintf(`        ${ret}${instantiation}getCallableFromArray(%s, %s)(%s);\n`, class_, this._export(callable[1]), args.join(', '));
            }

            return __jymfony.sprintf(`        ${ret}${instantiation}%s(%s);\n`, this._dumpLiteralClass(this._dumpValue(callable)), args.join(', '));
        }

        return __jymfony.sprintf(`        ${ret}${instantiation}new %s(%s);\n`, this._dumpLiteralClass(class_), args.join(', '));
    }

    /**
     * @returns {string}
     *
     * @private
     */
    _getNextVariableName() {
        let name = '';
        let i = this._variableCount;

        if ('' === name) {
            name += firstChars[i % firstChars.length];
            i = ~~(i / firstChars.length);
        }

        while (0 < i) {
            --i;
            name += nonFirstChars[i % nonFirstChars.length];
            i = ~~(i / nonFirstChars.length);
        }

        ++this._variableCount;
        return '$' + name;
    }

    /**
     * @param {string} id
     * @param {*} args
     * @param {boolean} [deep = false]
     * @param {Set} [visited = new Set()]
     *
     * @returns {boolean}
     *
     * @private
     */
    _hasReference(id, args, deep = false, visited = new Set()) {
        for (const argument of Object.values(args)) {
            if (argument instanceof Reference) {
                const argumentId = argument.toString();
                if (id === argumentId) {
                    return true;
                }

                if (deep && ! visited.has(argumentId) && 'service_container' !== argumentId) {
                    visited.add(argumentId);
                    const service = this._container.getDefinition(argumentId);

                    // Todo
                    // If (service.isLazy() && ! (this._getProxyDumper instanceof NullDumper))

                    args = [ ...service.getMethodCalls(), ...service.getShutdownCalls(), ...service.getArguments(), ...Object.values(service.getProperties()) ];
                    if (this._hasReference(id, args, deep, visited)) {
                        return true;
                    }
                }
            } else if (isArray(argument) || isObjectLiteral(argument)) {
                if (this._hasReference(id, argument, deep, visited)) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * @param {*} value
     *
     * @returns {string}
     *
     * @private
     */
    _getServiceConditionals(value) {
        const conditions = [];
        for (const service of ContainerBuilder.getInitializedConditionals(value)) {
            if (! this._container.hasDefinition(service)) {
                return 'false';
            }

            conditions.push(__jymfony.sprintf('undefined !== this->%s[\'%s\']', this._container.getDefinition(service).isPublic() ? 'services' : 'privates', service));
        }

        for (const service of ContainerBuilder.getServiceConditionals(value)) {
            if (this._container.hasDefinition(service) && ! this._container.getDefinition(service).isPublic()) {
                continue;
            }

            conditions.push(__jymfony.sprintf('this.has(\'%s\')', service));
        }

        if (0 === conditions.length) {
            return '';
        }

        return conditions.join(' && ');
    }

    /**
     * @param {*} value
     * @param {string} code
     *
     * @returns {string}
     *
     * @private
     */
    _wrapServiceConditionals(value, code) {
        const conditionals = this._getServiceConditionals(value);
        if (! conditionals.length) {
            return code;
        }

        code.split('\n').map(line => line ? '    ' + line : line).join('\n');
        return __jymfony.sprintf('        if (%s) {\n%s        }\n', conditionals, code);
    }
}
